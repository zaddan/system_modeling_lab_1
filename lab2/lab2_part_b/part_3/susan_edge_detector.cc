//////////////////////////////////////////////////////////////////////
// C++ source file generated by SpecC V2.2.1
// Design: susan_edge_detector
// File:   susan_edge_detector.cc
// Time:   Sun Nov  1 09:20:14 2015
//////////////////////////////////////////////////////////////////////

// Note: User-defined include files are inlined in this file.

// Note: System-defined include files are inlined in this file.

#include "susan_edge_detector.h"


unsigned int _IDcnt = 0;
// channel class definitions /////////////////////////////////////////

c_double_handshake_signal::c_double_handshake_signal()
    : _specc::channel(),
    v(false),
    w(false)
{   /* nothing */
}

c_double_handshake_signal::~c_double_handshake_signal(void)
{   /* nothing */
}

#line 14 "./c_double_handshake_signal.sc"
void c_double_handshake_signal::receive(void)
{   
    if ( !v)
    {   
	w = true;
	_specc::wait(event(&req), ((void*)0));
	w = false;
    }
    v = false;
    _specc::notify(event(&ack), ((void*)0));
    _specc::wait(event(&ack), ((void*)0));
}

void c_double_handshake_signal::send(void)
{   
    v = true;
    if (w)
    {   
	_specc::notify(event(&req), ((void*)0));
    }
    _specc::wait(event(&ack), ((void*)0));
}

#line 54 "susan_edge_detector.cc"
MasterHardwareBus::MasterHardwareBus(_specc::signal<bit<_BITLEN(1,0),true> > (&A), _specc::signal<bit<_BITLEN(31,0),true> > (&D), _specc::signal<bit<_BITLEN(0,0),true> > (&ready), _specc::signal<bit<_BITLEN(0,0),true> > (&ack))
    : _specc::channel(), A(A), D(D), ready(ready), ack(ack)
{   /* nothing */
}

MasterHardwareBus::~MasterHardwareBus(void)
{   /* nothing */
}

#line 70 "HWBus.sc"
void MasterHardwareBus::masterRead(bit<_BITLEN(1,0),true> a, bit<_BITLEN(31,0),true> *d)
{   
    { unsigned long long _scc_time_stamp_t1, _scc_time_stamp_t2, _scc_time_stamp_t3, _scc_time_stamp_t4; {
	    t1: _scc_time_stamp_t1 = _specc::getCurrentTime(); A = a;
	    _specc::waitfor((5000));
	    t2: _scc_time_stamp_t2 = _specc::getCurrentTime(); ready = 1;
	    while( !((ack).test())) _specc::wait(event(&ack), ((void*)0));
	    t3: _scc_time_stamp_t3 = _specc::getCurrentTime();  *d = ((bit<_BITLEN(31,0),true>)D);
	    _specc::waitfor((15000));
	    t4: _scc_time_stamp_t4 = _specc::getCurrentTime(); ready = 0;
	    while(((ack).test())) _specc::wait(event(&ack), ((void*)0));
	}

	_scc_range_check(_scc_time_stamp_t1, _scc_time_stamp_t2, 5000ll, true, 15000ll, true, "t1", "t2", "HWBus.sc", 83);
	_scc_range_check(_scc_time_stamp_t3, _scc_time_stamp_t4, 10000ll, true, 25000ll, true, "t3", "t4", "HWBus.sc", 84);
    }
}

#line 52 "HWBus.sc"
void MasterHardwareBus::masterWrite(bit<_BITLEN(1,0),true> a, bit<_BITLEN(31,0),true> d)
{   
    { unsigned long long _scc_time_stamp_t1, _scc_time_stamp_t2, _scc_time_stamp_t3, _scc_time_stamp_t4; {
	    t1: _scc_time_stamp_t1 = _specc::getCurrentTime(); A = a;
	    D = d;
	    _specc::waitfor((5000));
	    t2: _scc_time_stamp_t2 = _specc::getCurrentTime(); ready = 1;
	    while( !((ack).test())) _specc::wait(event(&ack), ((void*)0));
	    t3: _scc_time_stamp_t3 = _specc::getCurrentTime(); _specc::waitfor((10000));
	    t4: _scc_time_stamp_t4 = _specc::getCurrentTime(); ready = 0;
	    while(((ack).test())) _specc::wait(event(&ack), ((void*)0));
	}

	_scc_range_check(_scc_time_stamp_t1, _scc_time_stamp_t2, 5000ll, true, 15000ll, true, "t1", "t2", "HWBus.sc", 65);
	_scc_range_check(_scc_time_stamp_t3, _scc_time_stamp_t4, 10000ll, true, 25000ll, true, "t3", "t4", "HWBus.sc", 66);
    }
}

#line 102 "susan_edge_detector.cc"
HardwareBusProtocolTLM::HardwareBusProtocolTLM(_specc::signal<bit<_BITLEN(1,0),true> > (&A), _specc::signal<bit<_BITLEN(31,0),true> > (&D), _specc::event (&TLMEvent1), _specc::event (&TLMEvent2))
    : _specc::channel(), A(A), D(D), TLMEvent1(TLMEvent1), TLMEvent2(TLMEvent2)
{   /* nothing */
}

HardwareBusProtocolTLM::~HardwareBusProtocolTLM(void)
{   /* nothing */
}

#line 107 "HWBus.sc"
void HardwareBusProtocolTLM::masterRead(bit<_BITLEN(1,0),true> a, bit<_BITLEN(31,0),true> *d)
{   

    _specc::wait(event(&TLMEvent2), ((void*)0));

    A = a;
     *d = ((bit<_BITLEN(31,0),true>)D);
    _specc::waitfor((20000));
}

#line 98 "HWBus.sc"
void HardwareBusProtocolTLM::masterWrite(bit<_BITLEN(1,0),true> a, bit<_BITLEN(31,0),true> d)
{   
    A = a;
    D = d;
    _specc::notify(event(&TLMEvent1), ((void*)0));
    _specc::waitfor((20000));
}

#line 125 "HWBus.sc"
void HardwareBusProtocolTLM::slaveRead(bit<_BITLEN(1,0),true> a, bit<_BITLEN(31,0),true> *d)
{   

    _specc::wait(event(&TLMEvent1), ((void*)0));
     *d = ((bit<_BITLEN(31,0),true>)D);
    _specc::waitfor((20000));
}

#line 117 "HWBus.sc"
void HardwareBusProtocolTLM::slaveWrite(bit<_BITLEN(1,0),true> a, bit<_BITLEN(31,0),true> d)
{   

    D = d;
    _specc::notify(event(&TLMEvent2), ((void*)0));

    _specc::waitfor((20000));
}

#line 151 "susan_edge_detector.cc"
SlaveHardwareBus::SlaveHardwareBus(_specc::signal<bit<_BITLEN(1,0),true> > (&A), _specc::signal<bit<_BITLEN(31,0),true> > (&D), _specc::signal<bit<_BITLEN(0,0),true> > (&ready), _specc::signal<bit<_BITLEN(0,0),true> > (&ack))
    : _specc::channel(), A(A), D(D), ready(ready), ack(ack)
{   /* nothing */
}

SlaveHardwareBus::~SlaveHardwareBus(void)
{   /* nothing */
}

#line 165 "HWBus.sc"
void SlaveHardwareBus::slaveRead(bit<_BITLEN(1,0),true> a, bit<_BITLEN(31,0),true> *d)
{   
    { unsigned long long _scc_time_stamp_t1, _scc_time_stamp_t2, _scc_time_stamp_t3, _scc_time_stamp_t4, _scc_time_stamp_t5; {
	    t1: _scc_time_stamp_t1 = _specc::getCurrentTime(); while( !((ready).test())) _specc::wait(event(&ready), ((void*)0));
	    t2: _scc_time_stamp_t2 = _specc::getCurrentTime(); if (a != ((bit<_BITLEN(1,0),true>)A)) {
		    _specc::waitfor((1000));
		    goto t1;
		}
		else  {
		     *d = ((bit<_BITLEN(31,0),true>)D);
		    _specc::waitfor((12000));
		}
	    t3: _scc_time_stamp_t3 = _specc::getCurrentTime(); ack = 1;
	    while(((ready).test())) _specc::wait(event(&ready), ((void*)0));
	    t4: _scc_time_stamp_t4 = _specc::getCurrentTime(); _specc::waitfor((7000));
	    t5: _scc_time_stamp_t5 = _specc::getCurrentTime(); ack = 0;
	}

	_scc_range_check(_scc_time_stamp_t2, _scc_time_stamp_t3, 10000ll, true, 20000ll, true, "t2", "t3", "HWBus.sc", 183);
	_scc_range_check(_scc_time_stamp_t4, _scc_time_stamp_t5, 5000ll, true, 15000ll, true, "t4", "t5", "HWBus.sc", 184);
    }
}

#line 142 "HWBus.sc"
void SlaveHardwareBus::slaveWrite(bit<_BITLEN(1,0),true> a, bit<_BITLEN(31,0),true> d)
{   
    { unsigned long long _scc_time_stamp_t1, _scc_time_stamp_t2, _scc_time_stamp_t3, _scc_time_stamp_t4, _scc_time_stamp_t5; {
	    t1: _scc_time_stamp_t1 = _specc::getCurrentTime(); while( !((ready).test())) _specc::wait(event(&ready), ((void*)0));
	    t2: _scc_time_stamp_t2 = _specc::getCurrentTime(); if (a != ((bit<_BITLEN(1,0),true>)A)) {
		    _specc::waitfor((1000));
		    goto t1;
		}
		else  {
		    D = d;
		    _specc::waitfor((12000));
		}
	    t3: _scc_time_stamp_t3 = _specc::getCurrentTime(); ack = 1;
	    while(((ready).test())) _specc::wait(event(&ready), ((void*)0));
	    t4: _scc_time_stamp_t4 = _specc::getCurrentTime(); _specc::waitfor((7000));
	    t5: _scc_time_stamp_t5 = _specc::getCurrentTime(); ack = 0;
	}

	_scc_range_check(_scc_time_stamp_t2, _scc_time_stamp_t3, 10000ll, true, 20000ll, true, "t2", "t3", "HWBus.sc", 160);
	_scc_range_check(_scc_time_stamp_t4, _scc_time_stamp_t5, 5000ll, true, 15000ll, true, "t4", "t5", "HWBus.sc", 161);
    }
}

#line 209 "susan_edge_detector.cc"
MasterHardwareBusLinkAccess::MasterHardwareBusLinkAccess(IMasterHardwareBusProtocol (&protocol))
    : _specc::channel(), protocol(protocol)
{   /* nothing */
}

MasterHardwareBusLinkAccess::~MasterHardwareBusLinkAccess(void)
{   /* nothing */
}

#line 256 "HWBus.sc"
void MasterHardwareBusLinkAccess::MasterRead(int addr, void *data, unsigned long int len)
{   
    unsigned long int i;
    unsigned char *p;
    bit<_BITLEN(31,0),true> word;

    printf("in MasterRead_before _Read\n");
    for(p = (unsigned char *)data , i = 0; i < len; i++  , p++ )
    {   
	if ( !(i % 4u)) {
	    protocol.masterRead(addr,  &word);
	}

	 *p = ((unsigned char)((word(31,0, 31,24))).toInt());
	word = word << 8;
    }
    printf("in masterRead_after_wait\n");
}

#line 231 "HWBus.sc"
void MasterHardwareBusLinkAccess::MasterWrite(int addr, const void *data, unsigned long int len)
{   
    unsigned long int i;
    unsigned char *p;
    bit<_BITLEN(31,0),true> word = bit<32,true>("00000000000000000000000000000000");

    for(p = (unsigned char *)data , i = 0; i < len; i++  , p++ )
    {   
	word = (word << 8) +  *p;

	if ( !((i + 1) % 4u)) {
	    protocol.masterWrite(addr, word);
	    word = 0;
	}
    }

    if (i % 4u) {
	word <<= 8 * (4u - (i % 4u));
	protocol.masterWrite(addr, word);
    }
}

#line 262 "susan_edge_detector.cc"
SlaveHardwareBusLinkAccess::SlaveHardwareBusLinkAccess(ISlaveHardwareBusProtocol (&protocol))
    : _specc::channel(), protocol(protocol)
{   /* nothing */
}

SlaveHardwareBusLinkAccess::~SlaveHardwareBusLinkAccess(void)
{   /* nothing */
}

#line 305 "HWBus.sc"
void SlaveHardwareBusLinkAccess::SlaveRead(int addr, void *data, unsigned long int len)
{   
    unsigned long int i;
    unsigned char *p;
    bit<_BITLEN(31,0),true> word;

    for(p = (unsigned char *)data , i = 0; i < len; i++  , p++ )
    {   
	if ( !(i % 4u)) {
	    protocol.slaveRead(addr,  &word);
	}

	 *p = ((unsigned char)((word(31,0, 31,24))).toInt());
	word = word << 8;
    }
}

#line 279 "HWBus.sc"
void SlaveHardwareBusLinkAccess::SlaveWrite(int addr, const void *data, unsigned long int len)
{   
    unsigned long int i;
    unsigned char *p;
    bit<_BITLEN(31,0),true> word = bit<32,true>("00000000000000000000000000000000");


    for(p = (unsigned char *)data , i = 0; i < len; i++  , p++ )
    {   
	word = (word << 8) +  *p;

	if ( !((i + 1) % 4u)) {
	    protocol.slaveWrite(addr, word);
	    word = 0;
	}
    }

    if (i % 4u) {
	word <<= 8 * (4u - (i % 4u));
	protocol.slaveWrite(addr, word);
    }
}

#line 314 "susan_edge_detector.cc"
HardwareBus::HardwareBus()
    : _specc::channel(),
    ack(bit<1,true>("0")),
    int0(bit<1,true>("0")),
    int1(bit<1,true>("0")),
    ready(bit<1,true>("0")),
    MasterLink(myHardwareBusProtocolTLM),
    SlaveLink(myHardwareBusProtocolTLM),
    SlaveSync1(),
    SlaveSync2(),
    myHardwareBusProtocolTLM(A, D, TLMEvent1, TLMEvent2)
{   /* nothing */
}

HardwareBus::~HardwareBus(void)
{   /* nothing */
}

#line 390 "HWBus.sc"
void HardwareBus::MasterRead(bit<_BITLEN(1,0),true> addr, void *data, unsigned long int len) {
    MasterLink.MasterRead(((addr).toInt()), data, len);
}

#line 404 "HWBus.sc"
void HardwareBus::MasterSyncReceive() {
    char myChar = 'c';
    unsigned long int mySize = 1ul;
    SlaveSync1.receive( &myChar, mySize);
}



void HardwareBus::MasterSyncReceive2() {
    char myChar = 'c';
    unsigned long int mySize = 1ul;
    SlaveSync2.receive( &myChar, mySize);
}

#line 393 "HWBus.sc"
void HardwareBus::MasterWrite(bit<_BITLEN(1,0),true> addr, const void *data, unsigned long int len) {
    MasterLink.MasterWrite(((addr).toInt()), data, len);
}

void HardwareBus::SlaveRead(bit<_BITLEN(1,0),true> addr, void *data, unsigned long int len) {
    SlaveLink.SlaveRead(((addr).toInt()), data, len);
}

#line 419 "HWBus.sc"
void HardwareBus::SlaveSyncSend() {
    char myChar = 'c';
    unsigned long int mySize = 1ul;
    SlaveSync1.send( &myChar, mySize);
}




void HardwareBus::SlaveSyncSend2() {
    char myChar = 'c';
    unsigned long int mySize = 1ul;
    SlaveSync2.send( &myChar, mySize);

    printf("after slaveSYnc2 send %llu\n", now());
}

#line 400 "HWBus.sc"
void HardwareBus::SlaveWrite(bit<_BITLEN(1,0),true> addr, const void *data, unsigned long int len) {
    SlaveLink.SlaveWrite(((addr).toInt()), data, len);
}

#line 385 "susan_edge_detector.cc"
OS::OS()
    : _specc::channel(),
    QueueEmpty(1),
    QueueFull(0),
    current(0),
    head(-1),
    master(3),
    nullTask(-1),
    tail(-1),
    task1(0),
    task2(1),
    task3(2),
    task4(3)
{   /* nothing */
}

OS::~OS(void)
{   /* nothing */
}

#line 162 "OS.sc"
void OS::dispatch(void) {
    current = schedule();
    if (current != nullTask)
	trigger_event(current);
}

#line 62 "OS.sc"
void OS::increment_head() {
    head++ ;
    if (head == 40)
	head = 0;
}

#line 52 "OS.sc"
void OS::increment_tail() {
    tail++ ;
    if (tail == 40)
	tail = 0;
}

#line 177 "OS.sc"
void OS::par_end(int t) {
    ;
}

#line 173 "OS.sc"
int OS::par_start(void) {
    return current;
}

#line 105 "OS.sc"
int OS::pop() {
    int taskID;
    if (QueueEmpty) {

	return nullTask;
    }
    else  {
	taskID = readyQueue[head];
	increment_head();
	if (head == tail) {
	    QueueEmpty = 1;
	}
	QueueFull = 0;


	return taskID;
    }
}

#line 213 "OS.sc"
void OS::post_wait(int t) {
    push(t);
    if (current == nullTask) dispatch();
    wait_event(t);
}

#line 207 "OS.sc"
int OS::pre_wait(void) {
    int t;
    t = current;

    dispatch(); return t;
}

#line 98 "OS.sc"
void OS::printQueue(void) {
    int i;
    for(i = 0; i < 40; i++ ) {
	printf("::%d", readyQueue[i]);
    }
    printf("\n");
}

#line 67 "OS.sc"
bool OS::push(int taskID) {




    if (tail ==  -1) {
	tail = 0;
	head = 0;
	readyQueue[0] = taskID;

	increment_tail();
	QueueEmpty = 0;
	return true;
    }
    else  if (QueueFull) {
	    return false;
	}
	else 

#line 83 "OS.sc"
	{   

	    readyQueue[tail] = taskID;
	    increment_tail();
	    QueueEmpty = 0;
	    if (head == tail) {

		QueueFull = 1;
	    }
	    return true;
	}
    return true;
}

#line 158 "OS.sc"
int OS::schedule(void) {
    return pop();
}

#line 58 "OS.sc"
void OS::start(int task_id) {
    current = task_id;
}

#line 183 "OS.sc"
void OS::task_activate(int t) {

    if ((t != task1) && (t != master)) {
	push(t);

	wait_event(t);
    }
    current = t;
}

#line 169 "OS.sc"
void OS::task_terminate() {
    dispatch();
}

#line 202 "OS.sc"
void OS::time_wait(int t) {
    _specc::waitfor((t));

    yield();
}

#line 125 "OS.sc"
void OS::trigger_event(int taskID) {
    switch(taskID) {
	case 0:
	    _specc::notify(event(&e1), ((void*)0));
	break;
	case 1:
	    _specc::notify(event(&e2), ((void*)0));
	break;
	case 2:
	    _specc::notify(event(&e3), ((void*)0));
	break;
	case 3:
	    _specc::notify(event(&e4), ((void*)0));
	break;
    }
}

void OS::wait_event(int taskID) {
    switch(taskID) {
	case 0:
	    _specc::wait(event(&e1), ((void*)0));
	break;
	case 1:
	    _specc::wait(event(&e2), ((void*)0));
	break;
	case 2:
	    _specc::wait(event(&e3), ((void*)0));
	break;
	case 3:
	    _specc::wait(event(&e4), ((void*)0));
	break;
    }
}

#line 194 "OS.sc"
void OS::yield() {
    int task;
    task = current;
    push(task);

    dispatch();
    wait_event(task);
}

#line 594 "susan_edge_detector.cc"
c_double_handshake::c_double_handshake()
    : _specc::channel(),
    v(false),
    w(false)
{   /* nothing */
}

c_double_handshake::~c_double_handshake(void)
{   /* nothing */
}

#line 81 "c_double_handshake.sc"
void c_double_handshake::receive(void *d, unsigned long int l)
{   
    if ( !v)
    {   
	w = true;
	_specc::wait(event(&req), ((void*)0));
	w = false;
    }
    if (l != tmpl)
    {   
	abort();
    }
    memcpy(d, tmpd, l);
    v = false;
    _specc::notify(event(&ack), ((void*)0));
    _specc::wait(event(&ack), ((void*)0));
}

void c_double_handshake::send(const void *d, unsigned long int l)
{   
    tmpd = d;
    tmpl = l;
    v = true;
    if (w)
    {   
	_specc::notify(event(&req), ((void*)0));
    }
    _specc::wait(event(&ack), ((void*)0));
}

#line 637 "susan_edge_detector.cc"
c_handshake::c_handshake()
    : _specc::channel(),
    f(false),
    w(false)
{   /* nothing */
}

c_handshake::~c_handshake(void)
{   /* nothing */
}

#line 62 "c_handshake.sc"
void c_handshake::receive(void)
{   
    if ( !f)
    {   
	w = true;
	_specc::wait(event(&e), ((void*)0));
	w = false;
    }
    f = false;
}

void c_handshake::send(void)
{   
    if (w)
    {   
	_specc::notify(event(&e), ((void*)0));
    }
    f = true;
}

#line 670 "susan_edge_detector.cc"
c_int7220_queue_R::c_int7220_queue_R(const unsigned long int (&size), OSAPI (&myOS))
    : _specc::channel(), size(size), myOS(myOS),
    buffer(0),
    n(0ul),
    p(0ul),
    wr(0ul),
    ws(0ul)
{   /* nothing */
}

c_int7220_queue_R::~c_int7220_queue_R(void)
{   /* nothing */
}

#line 11 "c_int7220_queue_both_SR.sc"
void c_int7220_queue_R::cleanup(void) { if ( !n) { free(buffer); buffer = 0;
    }
}

#line 11 "c_int7220_queue_both_SR.sc"
void c_int7220_queue_R::receive(int (*d)[7220]) { while( !n) { wr++ ; t = myOS.pre_wait(); _specc::wait(event(&r), ((void*)0)); myOS.post_wait(t); wr-- ;
    }

#line 11 "c_int7220_queue_both_SR.sc"
    if (n <= p) { { unsigned int _scc_index_0; for(_scc_index_0=0;_scc_index_0<7220;_scc_index_0++) ( *d)[_scc_index_0] = (buffer[p - n])[_scc_index_0]; }
    }
    else 

#line 11 "c_int7220_queue_both_SR.sc"
    {    { unsigned int _scc_index_0; for(_scc_index_0=0;_scc_index_0<7220;_scc_index_0++) ( *d)[_scc_index_0] = (buffer[p + size - n])[_scc_index_0]; }
    }

#line 11 "c_int7220_queue_both_SR.sc"
    n-- ; if (ws) { _specc::notify(event(&s), ((void*)0));
    }

#line 11 "c_int7220_queue_both_SR.sc"
    cleanup();
}

#line 11 "c_int7220_queue_both_SR.sc"
void c_int7220_queue_R::send(int d[7220]) { while(n >= size) { ws++ ; _specc::wait(event(&s), ((void*)0)); ws-- ;
    }

#line 11 "c_int7220_queue_both_SR.sc"
    setup(); { unsigned int _scc_index_0; for(_scc_index_0=0;_scc_index_0<7220;_scc_index_0++) (buffer[p])[_scc_index_0] = (d)[_scc_index_0]; } p++ ; if (p >= size) { p = 0;
    }

#line 11 "c_int7220_queue_both_SR.sc"
    n++ ; if (wr) { _specc::notify(event(&r), ((void*)0));
    }
}

#line 11 "c_int7220_queue_both_SR.sc"
void c_int7220_queue_R::setup(void) { if ( !buffer) { int dummy[7220]; unsigned long int i; if ( !(buffer = (int (*)[7220])malloc(sizeof(int [7220]) * size))) { perror("c_typed_queue"); abort();
	}

#line 11 "c_int7220_queue_both_SR.sc"
	for(i = 0; i < size; i++ ) { memcpy( &buffer[i],  &dummy, sizeof(int [7220]));
	}
    }
}

#line 734 "susan_edge_detector.cc"
c_int7220_queue_S::c_int7220_queue_S(const unsigned long int (&size), OSAPI (&myOS))
    : _specc::channel(), size(size), myOS(myOS),
    buffer(0),
    n(0ul),
    p(0ul),
    wr(0ul),
    ws(0ul)
{   /* nothing */
}

c_int7220_queue_S::~c_int7220_queue_S(void)
{   /* nothing */
}

#line 11 "c_int7220_queue_both_SR.sc"
void c_int7220_queue_S::cleanup(void) { if ( !n) { free(buffer); buffer = 0;
    }
}

#line 11 "c_int7220_queue_both_SR.sc"
void c_int7220_queue_S::receive(int (*d)[7220]) { while( !n) { wr++ ; _specc::wait(event(&r), ((void*)0)); wr-- ;
    }

#line 11 "c_int7220_queue_both_SR.sc"
    if (n <= p) { { unsigned int _scc_index_0; for(_scc_index_0=0;_scc_index_0<7220;_scc_index_0++) ( *d)[_scc_index_0] = (buffer[p - n])[_scc_index_0]; }
    }
    else 

#line 11 "c_int7220_queue_both_SR.sc"
    {    { unsigned int _scc_index_0; for(_scc_index_0=0;_scc_index_0<7220;_scc_index_0++) ( *d)[_scc_index_0] = (buffer[p + size - n])[_scc_index_0]; }
    }

#line 11 "c_int7220_queue_both_SR.sc"
    n-- ; if (ws) { _specc::notify(event(&s), ((void*)0));
    }

#line 11 "c_int7220_queue_both_SR.sc"
    cleanup();
}

#line 11 "c_int7220_queue_both_SR.sc"
void c_int7220_queue_S::send(int d[7220]) { while(n >= size) { ws++ ; t = myOS.pre_wait(); _specc::wait(event(&s), ((void*)0)); myOS.post_wait(t); ws-- ;
    }

#line 11 "c_int7220_queue_both_SR.sc"
    setup(); { unsigned int _scc_index_0; for(_scc_index_0=0;_scc_index_0<7220;_scc_index_0++) (buffer[p])[_scc_index_0] = (d)[_scc_index_0]; } p++ ; if (p >= size) { p = 0;
    }

#line 11 "c_int7220_queue_both_SR.sc"
    n++ ; if (wr) { _specc::notify(event(&r), ((void*)0));
    }
}

#line 11 "c_int7220_queue_both_SR.sc"
void c_int7220_queue_S::setup(void) { if ( !buffer) { int dummy[7220]; unsigned long int i; if ( !(buffer = (int (*)[7220])malloc(sizeof(int [7220]) * size))) { perror("c_typed_queue"); abort();
	}

#line 11 "c_int7220_queue_both_SR.sc"
	for(i = 0; i < size; i++ ) { memcpy( &buffer[i],  &dummy, sizeof(int [7220]));
	}
    }
}

#line 798 "susan_edge_detector.cc"
c_int7220_queue_both_SR::c_int7220_queue_both_SR(const unsigned long int (&size), OSAPI (&myOS))
    : _specc::channel(), size(size), myOS(myOS),
    buffer(0),
    n(0ul),
    p(0ul),
    wr(0ul),
    ws(0ul)
{   /* nothing */
}

c_int7220_queue_both_SR::~c_int7220_queue_both_SR(void)
{   /* nothing */
}

#line 11 "c_int7220_queue_both_SR.sc"
void c_int7220_queue_both_SR::cleanup(void) { if ( !n) { free(buffer); buffer = 0;
    }
}

#line 11 "c_int7220_queue_both_SR.sc"
void c_int7220_queue_both_SR::receive(int (*d)[7220]) { while( !n) { wr++ ; t = myOS.pre_wait(); _specc::wait(event(&r), ((void*)0)); myOS.post_wait(t); wr-- ;
    }

#line 11 "c_int7220_queue_both_SR.sc"
    if (n <= p) { { unsigned int _scc_index_0; for(_scc_index_0=0;_scc_index_0<7220;_scc_index_0++) ( *d)[_scc_index_0] = (buffer[p - n])[_scc_index_0]; }
    }
    else 

#line 11 "c_int7220_queue_both_SR.sc"
    {    { unsigned int _scc_index_0; for(_scc_index_0=0;_scc_index_0<7220;_scc_index_0++) ( *d)[_scc_index_0] = (buffer[p + size - n])[_scc_index_0]; }
    }

#line 11 "c_int7220_queue_both_SR.sc"
    n-- ; if (ws) { _specc::notify(event(&s), ((void*)0));
    }

#line 11 "c_int7220_queue_both_SR.sc"
    cleanup();
}

#line 11 "c_int7220_queue_both_SR.sc"
void c_int7220_queue_both_SR::send(int d[7220]) { while(n >= size) { ws++ ; x = myOS.pre_wait(); _specc::wait(event(&s), ((void*)0)); myOS.post_wait(x); ws-- ;
    }

#line 11 "c_int7220_queue_both_SR.sc"
    setup(); { unsigned int _scc_index_0; for(_scc_index_0=0;_scc_index_0<7220;_scc_index_0++) (buffer[p])[_scc_index_0] = (d)[_scc_index_0]; } p++ ; if (p >= size) { p = 0;
    }

#line 11 "c_int7220_queue_both_SR.sc"
    n++ ; if (wr) { _specc::notify(event(&r), ((void*)0));
    }
}

#line 11 "c_int7220_queue_both_SR.sc"
void c_int7220_queue_both_SR::setup(void) { if ( !buffer) { int dummy[7220]; unsigned long int i; if ( !(buffer = (int (*)[7220])malloc(sizeof(int [7220]) * size))) { perror("c_typed_queue"); abort();
	}

#line 11 "c_int7220_queue_both_SR.sc"
	for(i = 0; i < size; i++ ) { memcpy( &buffer[i],  &dummy, sizeof(int [7220]));
	}
    }
}

#line 862 "susan_edge_detector.cc"
c_queue::c_queue(const unsigned long int (&size))
    : _specc::channel(), size(size),
    buffer(0),
    n(0ul),
    p(0ul),
    wr(0ul),
    ws(0ul)
{   /* nothing */
}

c_queue::~c_queue(void)
{   /* nothing */
}

#line 99 "c_queue.sc"
void c_queue::cleanup(void)
{   
    if ( !n)
    {   
	free(buffer);
	buffer = 0;
    }
}

void c_queue::receive(void *d, unsigned long int l)
{   
    unsigned long int p0;

    while(l > n)
    {   
	wr++ ;
	_specc::wait(event(&r), ((void*)0));
	wr-- ;
    }

    if (n <= p)
    {   
	p0 = p - n;
    }
    else 
    {   
	p0 = p + size - n;
    }
    if (l <= size - p0)
    {   
	memcpy(d,  &buffer[p0], l);
	n -= l;
    }
    else 
    {   
	memcpy(d,  &buffer[p0], size - p0);
	memcpy(((char *)d) + (size - p0),  &buffer[0], l - (size - p0));
	n -= l;
    }

    if (ws)
    {   
	_specc::notify(event(&s), ((void*)0));
    }

    cleanup();
}

void c_queue::send(const void *d, unsigned long int l)
{   
    while(l > size - n)
    {   
	ws++ ;
	_specc::wait(event(&s), ((void*)0));
	ws-- ;
    }

    setup();

    if (l <= size - p)
    {   
	memcpy( &buffer[p], d, l);
	p += l;
	n += l;
    }
    else 
    {   
	memcpy( &buffer[p], d, size - p);
	memcpy( &buffer[0], ((char *)d) + (size - p), l - (size - p));
	p = l - (size - p);
	n += l;
    }

    if (wr)
    {   
	_specc::notify(event(&r), ((void*)0));
    }
}

#line 87 "c_queue.sc"
void c_queue::setup(void)
{   
    if ( !buffer)
    {   
	if ( !(buffer = (char *)malloc(size)))
	{   
	    perror("c_queue");
	    abort();
	}
    }
}

#line 970 "susan_edge_detector.cc"
c_uchar7220_queue_R::c_uchar7220_queue_R(const unsigned long int (&size), OSAPI (&myOS))
    : _specc::channel(), size(size), myOS(myOS),
    buffer(0),
    n(0ul),
    p(0ul),
    wr(0ul),
    ws(0ul)
{   /* nothing */
}

c_uchar7220_queue_R::~c_uchar7220_queue_R(void)
{   /* nothing */
}

#line 13 "c_uchar7220_queue_both_SR.sc"
void c_uchar7220_queue_R::cleanup(void) { if ( !n) { free(buffer); buffer = 0;
    }
}

#line 13 "c_uchar7220_queue_both_SR.sc"
void c_uchar7220_queue_R::receive(unsigned char (*d)[7220]) { while( !n) { wr++ ; t = myOS.pre_wait(); _specc::wait(event(&r), ((void*)0)); myOS.post_wait(t); wr-- ;
    }

#line 13 "c_uchar7220_queue_both_SR.sc"
    if (n <= p) { { unsigned int _scc_index_0; for(_scc_index_0=0;_scc_index_0<7220;_scc_index_0++) ( *d)[_scc_index_0] = (buffer[p - n])[_scc_index_0]; }
    }
    else 

#line 13 "c_uchar7220_queue_both_SR.sc"
    {    { unsigned int _scc_index_0; for(_scc_index_0=0;_scc_index_0<7220;_scc_index_0++) ( *d)[_scc_index_0] = (buffer[p + size - n])[_scc_index_0]; }
    }

#line 13 "c_uchar7220_queue_both_SR.sc"
    n-- ; if (ws) { _specc::notify(event(&s), ((void*)0));
    }

#line 13 "c_uchar7220_queue_both_SR.sc"
    cleanup();
}

#line 13 "c_uchar7220_queue_both_SR.sc"
void c_uchar7220_queue_R::send(unsigned char d[7220]) { while(n >= size) { ws++ ; _specc::wait(event(&s), ((void*)0)); ws-- ;
    }

#line 13 "c_uchar7220_queue_both_SR.sc"
    setup(); { unsigned int _scc_index_0; for(_scc_index_0=0;_scc_index_0<7220;_scc_index_0++) (buffer[p])[_scc_index_0] = (d)[_scc_index_0]; } p++ ; if (p >= size) { p = 0;
    }

#line 13 "c_uchar7220_queue_both_SR.sc"
    n++ ; if (wr) { _specc::notify(event(&r), ((void*)0));
    }
}

#line 13 "c_uchar7220_queue_both_SR.sc"
void c_uchar7220_queue_R::setup(void) { if ( !buffer) { unsigned char dummy[7220]; unsigned long int i; if ( !(buffer = (unsigned char (*)[7220])malloc(sizeof(unsigned char [7220]) * size))) { perror("c_typed_queue"); abort();
	}

#line 13 "c_uchar7220_queue_both_SR.sc"
	for(i = 0; i < size; i++ ) { memcpy( &buffer[i],  &dummy, sizeof(unsigned char [7220]));
	}
    }
}

#line 1034 "susan_edge_detector.cc"
c_uchar7220_queue_S::c_uchar7220_queue_S(const unsigned long int (&size), OSAPI (&myOS))
    : _specc::channel(), size(size), myOS(myOS),
    buffer(0),
    n(0ul),
    p(0ul),
    wr(0ul),
    ws(0ul)
{   /* nothing */
}

c_uchar7220_queue_S::~c_uchar7220_queue_S(void)
{   /* nothing */
}

#line 13 "c_uchar7220_queue_both_SR.sc"
void c_uchar7220_queue_S::cleanup(void) { if ( !n) { free(buffer); buffer = 0;
    }
}

#line 13 "c_uchar7220_queue_both_SR.sc"
void c_uchar7220_queue_S::receive(unsigned char (*d)[7220]) { while( !n) { wr++ ; _specc::wait(event(&r), ((void*)0)); wr-- ;
    }

#line 13 "c_uchar7220_queue_both_SR.sc"
    if (n <= p) { { unsigned int _scc_index_0; for(_scc_index_0=0;_scc_index_0<7220;_scc_index_0++) ( *d)[_scc_index_0] = (buffer[p - n])[_scc_index_0]; }
    }
    else 

#line 13 "c_uchar7220_queue_both_SR.sc"
    {    { unsigned int _scc_index_0; for(_scc_index_0=0;_scc_index_0<7220;_scc_index_0++) ( *d)[_scc_index_0] = (buffer[p + size - n])[_scc_index_0]; }
    }

#line 13 "c_uchar7220_queue_both_SR.sc"
    n-- ; if (ws) { _specc::notify(event(&s), ((void*)0));
    }

#line 13 "c_uchar7220_queue_both_SR.sc"
    cleanup();
}

#line 13 "c_uchar7220_queue_both_SR.sc"
void c_uchar7220_queue_S::send(unsigned char d[7220]) { while(n >= size) { ws++ ; t = myOS.pre_wait(); _specc::wait(event(&s), ((void*)0)); myOS.post_wait(t); ws-- ;
    }

#line 13 "c_uchar7220_queue_both_SR.sc"
    setup(); { unsigned int _scc_index_0; for(_scc_index_0=0;_scc_index_0<7220;_scc_index_0++) (buffer[p])[_scc_index_0] = (d)[_scc_index_0]; } p++ ; if (p >= size) { p = 0;
    }

#line 13 "c_uchar7220_queue_both_SR.sc"
    n++ ; if (wr) { _specc::notify(event(&r), ((void*)0));
    }
}

#line 13 "c_uchar7220_queue_both_SR.sc"
void c_uchar7220_queue_S::setup(void) { if ( !buffer) { unsigned char dummy[7220]; unsigned long int i; if ( !(buffer = (unsigned char (*)[7220])malloc(sizeof(unsigned char [7220]) * size))) { perror("c_typed_queue"); abort();
	}

#line 13 "c_uchar7220_queue_both_SR.sc"
	for(i = 0; i < size; i++ ) { memcpy( &buffer[i],  &dummy, sizeof(unsigned char [7220]));
	}
    }
}

#line 1098 "susan_edge_detector.cc"
c_uchar7220_queue_both_SR::c_uchar7220_queue_both_SR(const unsigned long int (&size), OSAPI (&myOS))
    : _specc::channel(), size(size), myOS(myOS),
    buffer(0),
    n(0ul),
    p(0ul),
    wr(0ul),
    ws(0ul)
{   /* nothing */
}

c_uchar7220_queue_both_SR::~c_uchar7220_queue_both_SR(void)
{   /* nothing */
}

#line 13 "c_uchar7220_queue_both_SR.sc"
void c_uchar7220_queue_both_SR::cleanup(void) { if ( !n) { free(buffer); buffer = 0;
    }
}

#line 13 "c_uchar7220_queue_both_SR.sc"
void c_uchar7220_queue_both_SR::receive(unsigned char (*d)[7220]) { while( !n) { wr++ ; t = myOS.pre_wait(); _specc::wait(event(&r), ((void*)0)); myOS.post_wait(t); wr-- ;
    }

#line 13 "c_uchar7220_queue_both_SR.sc"
    if (n <= p) { { unsigned int _scc_index_0; for(_scc_index_0=0;_scc_index_0<7220;_scc_index_0++) ( *d)[_scc_index_0] = (buffer[p - n])[_scc_index_0]; }
    }
    else 

#line 13 "c_uchar7220_queue_both_SR.sc"
    {    { unsigned int _scc_index_0; for(_scc_index_0=0;_scc_index_0<7220;_scc_index_0++) ( *d)[_scc_index_0] = (buffer[p + size - n])[_scc_index_0]; }
    }

#line 13 "c_uchar7220_queue_both_SR.sc"
    n-- ; if (ws) { _specc::notify(event(&s), ((void*)0));
    }

#line 13 "c_uchar7220_queue_both_SR.sc"
    cleanup();
}

#line 13 "c_uchar7220_queue_both_SR.sc"
void c_uchar7220_queue_both_SR::send(unsigned char d[7220]) { while(n >= size) { ws++ ; x = myOS.pre_wait(); _specc::wait(event(&s), ((void*)0)); myOS.post_wait(x); ws-- ;
    }

#line 13 "c_uchar7220_queue_both_SR.sc"
    setup(); { unsigned int _scc_index_0; for(_scc_index_0=0;_scc_index_0<7220;_scc_index_0++) (buffer[p])[_scc_index_0] = (d)[_scc_index_0]; } p++ ; if (p >= size) { p = 0;
    }

#line 13 "c_uchar7220_queue_both_SR.sc"
    n++ ; if (wr) { _specc::notify(event(&r), ((void*)0));
    }
}

#line 13 "c_uchar7220_queue_both_SR.sc"
void c_uchar7220_queue_both_SR::setup(void) { if ( !buffer) { unsigned char dummy[7220]; unsigned long int i; if ( !(buffer = (unsigned char (*)[7220])malloc(sizeof(unsigned char [7220]) * size))) { perror("c_typed_queue"); abort();
	}

#line 13 "c_uchar7220_queue_both_SR.sc"
	for(i = 0; i < size; i++ ) { memcpy( &buffer[i],  &dummy, sizeof(unsigned char [7220]));
	}
    }
}

#line 1162 "susan_edge_detector.cc"
master_send_driver::master_send_driver(IMasterHardwareBus (&myHardwareBus), bit<_BITLEN(1,0),true> (&addr))
    : _specc::channel(), myHardwareBus(myHardwareBus), addr(addr),
    mySize(7220ul)
{   /* nothing */
}

master_send_driver::~master_send_driver(void)
{   /* nothing */
}

#line 9 "master_driver.sc"
void master_send_driver::send(unsigned char outImage[7220]) {

    printf("in_master_SEND \n");
    myHardwareBus.MasterSyncReceive2();
    printf("done with sync master send %llu \n", now());
    myHardwareBus.MasterWrite(addr, outImage, mySize);
}

#line 1182 "susan_edge_detector.cc"
master_receive_driver::master_receive_driver(IMasterHardwareBus (&myHardwareBus), bit<_BITLEN(1,0),true> (&addr))
    : _specc::channel(), myHardwareBus(myHardwareBus), addr(addr),
    mySize(7220ul)
{   /* nothing */
}

master_receive_driver::~master_receive_driver(void)
{   /* nothing */
}

#line 20 "master_driver.sc"
void master_receive_driver::receive(unsigned char (*inImage)[7220]) {
    printf("in master recieve \n");
    myHardwareBus.MasterSyncReceive();
    printf("done with sync master recieve %llu \n", now());
    myHardwareBus.MasterRead(addr, inImage, mySize);
}

#line 1201 "susan_edge_detector.cc"
slave_send_driver::slave_send_driver(ISlaveHardwareBus (&myHardwareBus), bit<_BITLEN(1,0),true> (&addr))
    : _specc::channel(), myHardwareBus(myHardwareBus), addr(addr),
    mySize(7220ul)
{   /* nothing */
}

slave_send_driver::~slave_send_driver(void)
{   /* nothing */
}

#line 9 "slave_driver.sc"
void slave_send_driver::send(unsigned char outImage[7220]) {
    myHardwareBus.SlaveSyncSend();
    printf("done with syncing in slave %llu \n", now());
    myHardwareBus.SlaveWrite(addr, outImage, mySize);
}

#line 1219 "susan_edge_detector.cc"
slave_receive_driver::slave_receive_driver(ISlaveHardwareBus (&myHardwareBus), bit<_BITLEN(1,0),true> (&addr))
    : _specc::channel(), myHardwareBus(myHardwareBus), addr(addr),
    mySize(7220ul)
{   /* nothing */
}

slave_receive_driver::~slave_receive_driver(void)
{   /* nothing */
}

#line 18 "slave_driver.sc"
void slave_receive_driver::receive(unsigned char (*outImage)[7220]) {
    printf("slave_recv_SYNC2_sent %llu\n", now());
    myHardwareBus.SlaveSyncSend2();
    printf("slave_recv_SYNC2_done %llu\n", now());
    myHardwareBus.SlaveRead(addr, outImage, mySize);
}

// behavior class definitions ////////////////////////////////////////

#line 1240 "susan_edge_detector.cc"
Design::Design(unsigned int _idcnt, i_receive (&start), unsigned char (&image_buffer)[7220], i_sender (&out_image_susan))
    : _specc::behavior(_idcnt), start(start), image_buffer(image_buffer), out_image_susan(out_image_susan),
    myHardwareBus(),
    myRead_image_driver(++_IDcnt, myHardwareBus, image_buffer, start),
    mySusan_driver_wrapper(++_IDcnt, myHardwareBus),
    myWrite_image_driver(++_IDcnt, myHardwareBus, out_image_susan)
{   /* nothing */
}

Design::~Design(void)
{   /* nothing */
}

#line 20 "design.sc"
void Design::main(void) {
    { _specc::fork _scc_fork_0(&myRead_image_driver), _scc_fork_1(&mySusan_driver_wrapper), _scc_fork_2(&myWrite_image_driver); _specc::par(
	    &_scc_fork_0, 
	    &_scc_fork_1, 
	    &_scc_fork_2, ((_specc::fork*)0));
    }
}

#line 1263 "susan_edge_detector.cc"
DetectEdges::DetectEdges(unsigned int _idcnt, i_uchar7220_receiver (&in_image), i_int7220_sender (&out_r), i_uchar7220_sender (&out_mid), i_uchar7220_sender (&out_image), OSAPI (&myOS))
    : _specc::behavior(_idcnt), in_image(in_image), out_r(out_r), out_mid(out_mid), out_image(out_image), myOS(myOS),
    setup_brightness_lut(_IDcnt, bp, myOS),
    susan_edges(_IDcnt, in_image, out_r, out_mid, bp, out_image, myOS)
{   /* nothing */
}

DetectEdges::~DetectEdges(void)
{   /* nothing */
}

#line 14 "detect_edges.sc"
void DetectEdges::main(void) {
    printf("________________\n");
    setup_brightness_lut.main();


    susan_edges.main();
    printf("detect_edges_end\n");
}

#line 1285 "susan_edge_detector.cc"
Edges::Edges(unsigned int _idcnt, i_uchar7220_receiver (&in_image), i_int7220_sender (&out_r), i_uchar7220_sender (&out_mid), i_uchar7220_sender (&out_image), OSAPI (&myOS))
    : _specc::behavior(_idcnt), in_image(in_image), out_r(out_r), out_mid(out_mid), out_image(out_image), myOS(myOS),
    detect_edges(_IDcnt, in_image, out_r, out_mid, out_image, myOS)
{   /* nothing */
}

Edges::~Edges(void)
{   /* nothing */
}

#line 32 "detect_edges.sc"
void Edges::main(void) {
    int task_id = 0;
    myOS.task_activate(task_id);
    { enum { _scc_state_0, _scc_state_detect_edges } _scc_next_state = _scc_state_detect_edges; do switch(_scc_next_state) {
	    case _scc_state_detect_edges: { detect_edges.main(); { _scc_next_state = _scc_state_detect_edges; break; } } case _scc_state_0: { _scc_next_state = _scc_state_0; break; } } while(_scc_next_state != _scc_state_0);
    }
}

#line 1305 "susan_edge_detector.cc"
EdgeDrawThread_PartA::EdgeDrawThread_PartA(unsigned int _idcnt, unsigned char (&image_buffer)[7220], unsigned char (&mid)[7220], int (&thID), OSAPI (&myOS))
    : _specc::behavior(_idcnt), image_buffer(image_buffer), mid(mid), thID(thID), myOS(myOS)
{   /* nothing */
}

EdgeDrawThread_PartA::~EdgeDrawThread_PartA(void)
{   /* nothing */
}

#line 8 "edge_draw.sc"
void EdgeDrawThread_PartA::main(void) {

    int i;
    unsigned char *inp; unsigned char *midp;
    int drawing_mode;

    drawing_mode = 0;
    if (drawing_mode == 0)
    {   

	midp = mid + 7220 / 2 * thID;
	for(i = 76 * 95 / 2 * thID; i < 76 * 95 / 2 * (thID + 1) + (thID + 1 == 2 && 76 * 95 % 2 != 0 ? 76 * 95 % 2 : 0); i++ )
	{   
	    if ( *midp < 8)
	    {   
		inp = image_buffer + (midp - mid) - 76 - 1;
		 *inp++  = 255;  *inp++  = 255;  *inp = 255; inp += 76 - 2;
		 *inp++  = 255;  *inp++ ;  *inp = 255; inp += 76 - 2;
		 *inp++  = 255;  *inp++  = 255;  *inp = 255;
	    }
	    midp++ ;
	    myOS.time_wait(12000000);
	}
    }
}

#line 1342 "susan_edge_detector.cc"
EdgeDrawThread_PartB::EdgeDrawThread_PartB(unsigned int _idcnt, unsigned char (&image_buffer)[7220], unsigned char (&mid)[7220], int (&thID), OSAPI (&myOS))
    : _specc::behavior(_idcnt), image_buffer(image_buffer), mid(mid), thID(thID), myOS(myOS)
{   /* nothing */
}

EdgeDrawThread_PartB::~EdgeDrawThread_PartB(void)
{   /* nothing */
}

#line 41 "edge_draw.sc"
void EdgeDrawThread_PartB::main(void) {

    int i;
    unsigned char *midp;
    int drawing_mode;

    drawing_mode = 0;


    midp = mid + 7220 / 2 * thID;

    for(i = 76 * 95 / 2 * thID; i < 76 * 95 / 2 * (thID + 1) + (thID + 1 == 2 && 76 * 95 % 2 != 0 ? 76 * 95 % 2 : 0); i++ )
    {   
	if ( *midp < 8)
	     *(image_buffer + (midp - mid)) = 0;
	midp++ ;

	myOS.time_wait(12000000);
    }
}

#line 1374 "susan_edge_detector.cc"
EdgeDraw_ReadInput::EdgeDraw_ReadInput(unsigned int _idcnt, i_uchar7220_receiver (&in_image), i_uchar7220_receiver (&in_mid), unsigned char (&image_buffer)[7220], unsigned char (&mid)[7220], OSAPI (&myOS))
    : _specc::behavior(_idcnt), in_image(in_image), in_mid(in_mid), image_buffer(image_buffer), mid(mid), myOS(myOS)
{   /* nothing */
}

EdgeDraw_ReadInput::~EdgeDraw_ReadInput(void)
{   /* nothing */
}

#line 67 "edge_draw.sc"
void EdgeDraw_ReadInput::main(void) {
    in_image.receive( &image_buffer);
    in_mid.receive( &mid);
}

#line 1390 "susan_edge_detector.cc"
EdgeDraw_WriteOutput::EdgeDraw_WriteOutput(unsigned int _idcnt, unsigned char (&image_buffer)[7220], i_uchar7220_sender (&out_image), OSAPI (&myOS))
    : _specc::behavior(_idcnt), image_buffer(image_buffer), out_image(out_image), myOS(myOS)
{   /* nothing */
}

EdgeDraw_WriteOutput::~EdgeDraw_WriteOutput(void)
{   /* nothing */
}

#line 75 "edge_draw.sc"
void EdgeDraw_WriteOutput::main(void) {
    int myTask;
    myTask = myOS.pre_wait();
    out_image.send(image_buffer);
    myOS.post_wait(myTask);
    printf("edgeDraw_Ended\n");
}

#line 1409 "susan_edge_detector.cc"
EdgeDraw_PartA::EdgeDraw_PartA(unsigned int _idcnt, unsigned char (&image_buffer)[7220], unsigned char (&mid)[7220], OSAPI (&myOS))
    : _specc::behavior(_idcnt), image_buffer(image_buffer), mid(mid), myOS(myOS),
    _scc_const_port_0(0),
    _scc_const_port_1(1),
    edge_draw_a_thread_0(_IDcnt, image_buffer, mid, _scc_const_port_0, myOS),
    edge_draw_a_thread_1(_IDcnt, image_buffer, mid, _scc_const_port_1, myOS)
{   /* nothing */
}

EdgeDraw_PartA::~EdgeDraw_PartA(void)
{   /* nothing */
}

#line 90 "edge_draw.sc"
void EdgeDraw_PartA::main(void) {
    edge_draw_a_thread_0.main();
    edge_draw_a_thread_1.main();
}

#line 1429 "susan_edge_detector.cc"
EdgeDraw_PartB::EdgeDraw_PartB(unsigned int _idcnt, unsigned char (&image_buffer)[7220], unsigned char (&mid)[7220], OSAPI (&myOS))
    : _specc::behavior(_idcnt), image_buffer(image_buffer), mid(mid), myOS(myOS),
    _scc_const_port_0(0),
    _scc_const_port_1(1),
    edge_draw_b_thread_0(_IDcnt, image_buffer, mid, _scc_const_port_0, myOS),
    edge_draw_b_thread_1(_IDcnt, image_buffer, mid, _scc_const_port_1, myOS)
{   /* nothing */
}

EdgeDraw_PartB::~EdgeDraw_PartB(void)
{   /* nothing */
}

#line 103 "edge_draw.sc"
void EdgeDraw_PartB::main(void) {
    edge_draw_b_thread_0.main();
    edge_draw_b_thread_1.main();
}

#line 1449 "susan_edge_detector.cc"
EdgeDraw::EdgeDraw(unsigned int _idcnt, i_uchar7220_receiver (&in_image), i_uchar7220_receiver (&in_mid), i_uchar7220_sender (&out_image), OSAPI (&myOS))
    : _specc::behavior(_idcnt), in_image(in_image), in_mid(in_mid), out_image(out_image), myOS(myOS),
    edge_draw_a(_IDcnt, image_buffer, mid, myOS),
    edge_draw_b(_IDcnt, image_buffer, mid, myOS),
    edge_draw_read_input(_IDcnt, in_image, in_mid, image_buffer, mid, myOS),
    edge_draw_write_output(_IDcnt, image_buffer, out_image, myOS)
{   /* nothing */
}

EdgeDraw::~EdgeDraw(void)
{   /* nothing */
}

#line 124 "edge_draw.sc"
void EdgeDraw::main(void) {

    { enum { _scc_state_0, _scc_state_edge_draw_read_input, _scc_state_edge_draw_a, _scc_state_edge_draw_b, _scc_state_edge_draw_write_output } _scc_next_state = _scc_state_edge_draw_read_input; do switch(_scc_next_state) {
	    case _scc_state_edge_draw_read_input: { edge_draw_read_input.main(); { _scc_next_state = _scc_state_edge_draw_a; break; } }
	    case _scc_state_edge_draw_a: { edge_draw_a.main(); { _scc_next_state = _scc_state_edge_draw_b; break; } }
	    case _scc_state_edge_draw_b: { edge_draw_b.main(); { _scc_next_state = _scc_state_edge_draw_write_output; break; } }
	    case _scc_state_edge_draw_write_output: { edge_draw_write_output.main(); { _scc_next_state = _scc_state_0; break; } } case _scc_state_0: { _scc_next_state = _scc_state_0; break; } } while(_scc_next_state != _scc_state_0);
    }
}

#line 1474 "susan_edge_detector.cc"
Draw::Draw(unsigned int _idcnt, i_uchar7220_receiver (&in_image), i_uchar7220_receiver (&in_mid), i_uchar7220_sender (&out_image), OSAPI (&myOS))
    : _specc::behavior(_idcnt), in_image(in_image), in_mid(in_mid), out_image(out_image), myOS(myOS),
    edge_draw(_IDcnt, in_image, in_mid, out_image, myOS)
{   /* nothing */
}

Draw::~Draw(void)
{   /* nothing */
}

#line 142 "edge_draw.sc"
void Draw::main(void) {
    int task_id = 2;
    myOS.task_activate(task_id);
    { enum { _scc_state_0, _scc_state_edge_draw } _scc_next_state = _scc_state_edge_draw; do switch(_scc_next_state) {
	    case _scc_state_edge_draw: { edge_draw.main(); { _scc_next_state = _scc_state_edge_draw; break; } } case _scc_state_0: { _scc_next_state = _scc_state_0; break; } } while(_scc_next_state != _scc_state_0);
    }
}

#line 1494 "susan_edge_detector.cc"
susan_driver_wrapper::susan_driver_wrapper(unsigned int _idcnt, IMasterHardwareBus (&myHardwareBus))
    : _specc::behavior(_idcnt), myHardwareBus(myHardwareBus),
    addr1(bit<2,true>("01")),
    addr2(bit<2,true>("10")),
    TASK_PE1(_IDcnt, myMaster_receive_driver, myMaster_send_driver, myOS),
    myMaster_receive_driver(myHardwareBus, addr1),
    myMaster_send_driver(myHardwareBus, addr2),
    myOS()
{   /* nothing */
}

susan_driver_wrapper::~susan_driver_wrapper(void)
{   /* nothing */
}

#line 40 "master_driver.sc"
void susan_driver_wrapper::main(void) {
    { enum { _scc_state_0, _scc_state_TASK_PE1 } _scc_next_state = _scc_state_TASK_PE1; do switch(_scc_next_state) {
	    case _scc_state_TASK_PE1: { TASK_PE1.main(); { _scc_next_state = _scc_state_TASK_PE1; break; } } case _scc_state_0: { _scc_next_state = _scc_state_0; break; } } while(_scc_next_state != _scc_state_0);
    }
}

#line 1517 "susan_edge_detector.cc"
Monitor::Monitor(unsigned int _idcnt, i_receiver (&img), i_receiver (&start_time_channel))
    : _specc::behavior(_idcnt), img(img), start_time_channel(start_time_channel)
{   /* nothing */
}

Monitor::~Monitor(void)
{   /* nothing */
}

#line 10 "monitor.sc"
void Monitor::main(void)
{   
    struct _IO_FILE *fd;
    unsigned char image_buffer[7220];
    char filename[100];
    int n;
    unsigned long long int start_time;
    for(n = 0; n < 5; n++ )
    {   
	start_time_channel.receive( &start_time, sizeof(unsigned long long int));
	sprintf(filename, "out.pgm");

	printf("Inside monitor %u %llu us\n", n, (now()));




	if ((fd = fopen(filename, "w")) == ((void *)0))

	{    fprintf(stderr, "Can't output image%s.\n", filename); exit(0);
	}

#line 29 "monitor.sc"
	;

	fprintf(fd, "P5\n");
	fprintf(fd, "%d %d\n", 76, 95);
	fprintf(fd, "255\n");

	img.receive(image_buffer, 7220 * sizeof(char));


	if (fwrite(image_buffer, 76 * 95, 1, fd) != 1)
	{    fprintf(stderr, "Can't write image %s.\n", filename); exit(0);
	}

#line 39 "monitor.sc"
	;

	fclose(fd);
	printf("Total process time: %llu us\n", (now() - start_time) / (1 * 1000000ull));
    }

    printf("Current time: %llu us\n", (now()) / (1 * 1000000ull));

    exit(0);
}

#line 1576 "susan_edge_detector.cc"
ReadImage::ReadImage(unsigned int _idcnt, i_receive (&start), unsigned char (&image_buffer)[7220], i_uchar7220_sender (&out_image))
    : _specc::behavior(_idcnt), start(start), image_buffer(image_buffer), out_image(out_image)
{   /* nothing */
}

ReadImage::~ReadImage(void)
{   /* nothing */
}

#line 9 "read_image.sc"
void ReadImage::main(void) {
    int i;
    unsigned char image_buffer_out[7220];

    while(true) {

	start.receive();
	printf("after start recvie image\n");
	for(i = 0; i < 7220; i++ ) {
	    image_buffer_out[i] = image_buffer[i];
	}

	out_image.send(image_buffer_out);
    }
}

#line 1603 "susan_edge_detector.cc"
SetupBrightnessLutThread::SetupBrightnessLutThread(unsigned int _idcnt, unsigned char (&bp)[516], int (&thID), OSAPI (&myOS))
    : _specc::behavior(_idcnt), bp(bp), thID(thID), myOS(myOS)
{   /* nothing */
}

SetupBrightnessLutThread::~SetupBrightnessLutThread(void)
{   /* nothing */
}

#line 6 "setup_brightness_lut.sc"
void SetupBrightnessLutThread::main(void) {
    int k;
    float temp;
    int form; int thresh;

    thresh = 20;
    form = 6;


    for(k = ( -256) + 512 / 2 * thID; k < ( -256) + 512 / 2 * thID + 512 / 2 + 1; k++ ) {
	temp = ((float)k) / ((float)thresh);
	temp = temp * temp;
	if (form == 6)
	    temp = temp * temp * temp;
	temp = 1.000000000000000e+02 * exp( -temp);
	bp[(k + 258)] = (unsigned char)temp;
	myOS.time_wait(2700);
    }
}

#line 1634 "susan_edge_detector.cc"
SetupBrightnessLut::SetupBrightnessLut(unsigned int _idcnt, unsigned char (&bp)[516], OSAPI (&myOS))
    : _specc::behavior(_idcnt), bp(bp), myOS(myOS),
    _scc_const_port_0(0),
    _scc_const_port_1(1),
    setup_brightness_thread_0(_IDcnt, bp, _scc_const_port_0, myOS),
    setup_brightness_thread_1(_IDcnt, bp, _scc_const_port_1, myOS)
{   /* nothing */
}

SetupBrightnessLut::~SetupBrightnessLut(void)
{   /* nothing */
}

#line 33 "setup_brightness_lut.sc"
void SetupBrightnessLut::main(void) {
    setup_brightness_thread_0.main();
    setup_brightness_thread_1.main();
}

#line 1654 "susan_edge_detector.cc"
readImage_driver_wrapper::readImage_driver_wrapper(unsigned int _idcnt, ISlaveHardwareBus (&myHardwareBus), unsigned char (&image_buffer)[7220], i_receive (&start))
    : _specc::behavior(_idcnt), myHardwareBus(myHardwareBus), image_buffer(image_buffer), start(start),
    addr(bit<2,true>("01")),
    myRead_image(_IDcnt, start, image_buffer, mySlave_send_driver),
    mySlave_send_driver(myHardwareBus, addr)
{   /* nothing */
}

readImage_driver_wrapper::~readImage_driver_wrapper(void)
{   /* nothing */
}

#line 32 "slave_driver.sc"
void readImage_driver_wrapper::main(void) {

    { enum { _scc_state_0, _scc_state_myRead_image } _scc_next_state = _scc_state_myRead_image; do switch(_scc_next_state) {
	    case _scc_state_myRead_image: { myRead_image.main(); { _scc_next_state = _scc_state_myRead_image; break; } } case _scc_state_0: { _scc_next_state = _scc_state_0; break; } } while(_scc_next_state != _scc_state_0);
    }
}

#line 1675 "susan_edge_detector.cc"
writeImage_driver_wrapper::writeImage_driver_wrapper(unsigned int _idcnt, ISlaveHardwareBus (&myHardwareBus), i_sender (&out_image_susan))
    : _specc::behavior(_idcnt), myHardwareBus(myHardwareBus), out_image_susan(out_image_susan),
    addr(bit<2,true>("10")),
    mySlave_receive_driver(myHardwareBus, addr),
    myWrite_image(_IDcnt, mySlave_receive_driver, out_image_susan)
{   /* nothing */
}

writeImage_driver_wrapper::~writeImage_driver_wrapper(void)
{   /* nothing */
}

#line 50 "slave_driver.sc"
void writeImage_driver_wrapper::main(void) {
    { enum { _scc_state_0, _scc_state_myWrite_image } _scc_next_state = _scc_state_myWrite_image; do switch(_scc_next_state) {
	    case _scc_state_myWrite_image: { myWrite_image.main(); { _scc_next_state = _scc_state_myWrite_image; break; } } case _scc_state_0: { _scc_next_state = _scc_state_0; break; } } while(_scc_next_state != _scc_state_0);
    }
}

#line 1695 "susan_edge_detector.cc"
Stimulus::Stimulus(unsigned int _idcnt, i_send (&start), unsigned char (&image_buffer)[7220], i_sender (&start_time_channel))
    : _specc::behavior(_idcnt), start(start), image_buffer(image_buffer), start_time_channel(start_time_channel)
{   /* nothing */
}

Stimulus::~Stimulus(void)
{   /* nothing */
}

#line 42 "stimulus.sc"
void Stimulus::get_image(char filename[200], unsigned char *image)
{   

    struct _IO_FILE *fd;
    char header[100];
    int tmp; int x_size; int y_size;

#line 53 "stimulus.sc"
    if ((fd = fopen(filename, "r")) == ((void *)0))

    {    fprintf(stderr, "Can't input image %s.\n", filename); exit(0);
    }

#line 55 "stimulus.sc"
    ;


    header[0] = fgetc(fd);
    header[1] = fgetc(fd);
    if ( !(header[0] == 'P' && header[1] == '5'))
    {    fprintf(stderr, "Image %s does not have binary PGM header.\n", filename); exit(0);
    }

#line 61 "stimulus.sc"
    ;

    x_size = getint(fd);
    y_size = getint(fd);
    tmp = getint(fd);

    if ((x_size != 76) || (y_size != 95)) {
	fprintf(stderr, "Input picture does not match size of %dx%d\n", 76, 95);
	fclose(fd);
	exit(1);
    }

    if (fread(image, 1, 76 * 95, fd) == 0)
    {    fprintf(stderr, "Image %s is wrong size.\n", filename); exit(0);
    }

#line 74 "stimulus.sc"
    ;
    fclose(fd);
}

#line 12 "stimulus.sc"
int Stimulus::getint(struct _IO_FILE *fd)
{   
    int c; int i;
    char dummy[10000];

    c = _IO_getc(fd);
    while(1)
    {   
	if (c == '#')
	    fgets(dummy, 9000, fd);
	if (c == ( -1))
	{    fprintf(stderr, "Image %s not binary PGM.\n", "is"); exit(0);
	}

#line 23 "stimulus.sc"
	;
	if (c >= '0' && c <= '9')
	    break;
	c = _IO_getc(fd);
    }


    i = 0;
    while(1) {
	i = (i * 10) + (c - '0');
	c = _IO_getc(fd);
	if (c == ( -1)) return (i);
	if (c < '0' || c > '9') break;
    }

    return (i);
}

#line 79 "stimulus.sc"
void Stimulus::main(void)
{   

    unsigned int n;
    char filename[100];
    unsigned long long int start_time;
    sprintf(filename, "%s", "input_small.pgm");
    get_image(filename, image_buffer);
    for(n = 0; n < 5; n++ ) {


	printf("Starting process %d...\n", n + 1);
	start.send();
	printf("start send\n");
	start_time = now();
	start_time_channel.send( &start_time, sizeof(unsigned long long int));
	_specc::waitfor((1000));
    }
}

#line 1806 "susan_edge_detector.cc"
Susan::Susan(unsigned int _idcnt, i_uchar7220_receiver (&in_image), i_uchar7220_sender (&out_image), OSAPI (&myOS))
    : _specc::behavior(_idcnt), in_image(in_image), out_image(out_image), myOS(myOS),
    _scc_const_port_0(1ul),
    _scc_const_port_1(1ul),
    _scc_const_port_2(1ul),
    _scc_const_port_3(1ul),
    draw(_IDcnt, image_edge_draw, mid_edge_draw, out_image, myOS),
    edges(_IDcnt, in_image, r, mid, image_edge_draw, myOS),
    image_edge_draw(_scc_const_port_0, myOS),
    mid(_scc_const_port_1, myOS),
    mid_edge_draw(_scc_const_port_2, myOS),
    r(_scc_const_port_3, myOS),
    thin(_IDcnt, r, mid, mid_edge_draw, myOS)
{   /* nothing */
}

Susan::~Susan(void)
{   /* nothing */
}

#line 21 "susan.sc"
void Susan::main(void)
{   
    int master;
    master = 3;
    myOS.start(master);
    master = myOS.par_start();
    { _specc::fork _scc_fork_0(&edges), _scc_fork_1(&thin), _scc_fork_2(&draw); _specc::par(
	    &_scc_fork_0, 
	    &_scc_fork_1, 
	    &_scc_fork_2, ((_specc::fork*)0));
    }
    myOS.par_end(master);
}

#line 1842 "susan_edge_detector.cc"
Main::Main(unsigned int _idcnt)
    : _specc::class_type(_idcnt),
    _scc_const_port_0(1000ul),
    design(_IDcnt, start, image_buffer, out_image),
    monitor(_IDcnt, out_image, start_time),
    out_image(),
    start(),
    start_time(_scc_const_port_0),
    stimulus(_IDcnt, start, image_buffer, start_time)
{   /* nothing */
}

Main::~Main(void)
{   /* nothing */
}

#line 22 "susan_edge_detector.sc"
int Main::main(void) {
    { _specc::fork _scc_fork_0(&stimulus), _scc_fork_1(&design), _scc_fork_2(&monitor); _specc::par(
	    &_scc_fork_0, 
	    &_scc_fork_1, 
	    &_scc_fork_2, ((_specc::fork*)0));
    }

    return 0;
}

#line 1870 "susan_edge_detector.cc"
Main _scc_main(_IDcnt);

int main(void)
{   
    int _scc_main_return;
    
    _specc::start();
    _scc_main_return = _scc_main.main();
    _specc::end();
    return(_scc_main_return);
}

SusanEdgesThread_PartA::SusanEdgesThread_PartA(unsigned int _idcnt, unsigned char (&image_buffer)[7220], int (&r)[7220], unsigned char (&bp)[516], int (&thID), OSAPI (&myOS))
    : _specc::behavior(_idcnt), image_buffer(image_buffer), r(r), bp(bp), thID(thID), myOS(myOS)
{   /* nothing */
}

SusanEdgesThread_PartA::~SusanEdgesThread_PartA(void)
{   /* nothing */
}

#line 9 "susan_edges.sc"
void SusanEdgesThread_PartA::main(void) {

    int max_no;
    int i; int j; int n;
    unsigned char *cp; unsigned char *p;

    max_no = 2650;

    for(i = 3 + (95 - 3 - 3) / 2 * thID; i < 3 + (95 - 3 - 3) / 2 * (thID + 1) + (thID + 1 == 2 && (95 - 3 - 3) % 2 != 0 ? (95 - 3 - 3) % 2 : 0); i++ )
    {   
	for(j = 3; j < 76 - 3; j++ )
	{   
	    n = 100;
	    p = image_buffer + (i - 3) * 76 + j - 1;
	    cp = bp + 258 + image_buffer[i * 76 + j];

	    n +=  *(cp -  *p++ );
	    n +=  *(cp -  *p++ );
	    n +=  *(cp -  *p);
	    p += 76 - 3;

	    n +=  *(cp -  *p++ );
	    n +=  *(cp -  *p++ );
	    n +=  *(cp -  *p++ );
	    n +=  *(cp -  *p++ );
	    n +=  *(cp -  *p);
	    p += 76 - 5;

	    n +=  *(cp -  *p++ );
	    n +=  *(cp -  *p++ );
	    n +=  *(cp -  *p++ );
	    n +=  *(cp -  *p++ );
	    n +=  *(cp -  *p++ );
	    n +=  *(cp -  *p++ );
	    n +=  *(cp -  *p);
	    p += 76 - 6;

	    n +=  *(cp -  *p++ );
	    n +=  *(cp -  *p++ );
	    n +=  *(cp -  *p);
	    p += 2;
	    n +=  *(cp -  *p++ );
	    n +=  *(cp -  *p++ );
	    n +=  *(cp -  *p);
	    p += 76 - 6;

	    n +=  *(cp -  *p++ );
	    n +=  *(cp -  *p++ );
	    n +=  *(cp -  *p++ );
	    n +=  *(cp -  *p++ );
	    n +=  *(cp -  *p++ );
	    n +=  *(cp -  *p++ );
	    n +=  *(cp -  *p);
	    p += 76 - 5;

	    n +=  *(cp -  *p++ );
	    n +=  *(cp -  *p++ );
	    n +=  *(cp -  *p++ );
	    n +=  *(cp -  *p++ );
	    n +=  *(cp -  *p);
	    p += 76 - 3;

	    n +=  *(cp -  *p++ );
	    n +=  *(cp -  *p++ );
	    n +=  *(cp -  *p);

	    if (n <= max_no)
		r[i * 76 + j] = max_no - n;
	}
	myOS.time_wait(19000000);
    }
}

#line 1966 "susan_edge_detector.cc"
SusanEdgesThread_PartB::SusanEdgesThread_PartB(unsigned int _idcnt, unsigned char (&image_buffer)[7220], int (&r)[7220], unsigned char (&mid)[7220], unsigned char (&bp)[516], int (&thID), OSAPI (&myOS))
    : _specc::behavior(_idcnt), image_buffer(image_buffer), r(r), mid(mid), bp(bp), thID(thID), myOS(myOS)
{   /* nothing */
}

SusanEdgesThread_PartB::~SusanEdgesThread_PartB(void)
{   /* nothing */
}

#line 88 "susan_edges.sc"
void SusanEdgesThread_PartB::main(void) {

    int max_no;
    float z;
    int a; int b; int do_symmetry; int i; int j; int m; int n; int w; int x; int y;
    unsigned char c; unsigned char *cp; unsigned char *p;

    max_no = 2650;



    for(i = 4 + (95 - 4 - 4) / 2 * thID; i < 4 + (95 - 4 - 4) / 2 * (thID + 1) + (thID + 1 == 2 && (95 - 4 - 4) % 2 != 0 ? (95 - 4 - 4) % 2 : 0); i++ ) {
	for(j = 4; j < 76 - 4; j++ )
	{   
	    if (r[i * 76 + j] > 0)
	    {   
		m = r[i * 76 + j];
		n = max_no - m;
		cp = bp + 258 + image_buffer[i * 76 + j];

		if (n > 600)
		{   
		    p = image_buffer + (i - 3) * 76 + j - 1;
		    x = 0; y = 0;

		    c =  *(cp -  *p++ ); x -= c; y -= 3 * c;
		    c =  *(cp -  *p++ ); y -= 3 * c;
		    c =  *(cp -  *p); x += c; y -= 3 * c;
		    p += 76 - 3;

		    c =  *(cp -  *p++ ); x -= 2 * c; y -= 2 * c;
		    c =  *(cp -  *p++ ); x -= c; y -= 2 * c;
		    c =  *(cp -  *p++ ); y -= 2 * c;
		    c =  *(cp -  *p++ ); x += c; y -= 2 * c;
		    c =  *(cp -  *p); x += 2 * c; y -= 2 * c;
		    p += 76 - 5;

		    c =  *(cp -  *p++ ); x -= 3 * c; y -= c;
		    c =  *(cp -  *p++ ); x -= 2 * c; y -= c;
		    c =  *(cp -  *p++ ); x -= c; y -= c;
		    c =  *(cp -  *p++ ); y -= c;
		    c =  *(cp -  *p++ ); x += c; y -= c;
		    c =  *(cp -  *p++ ); x += 2 * c; y -= c;
		    c =  *(cp -  *p); x += 3 * c; y -= c;
		    p += 76 - 6;

		    c =  *(cp -  *p++ ); x -= 3 * c;
		    c =  *(cp -  *p++ ); x -= 2 * c;
		    c =  *(cp -  *p); x -= c;
		    p += 2;
		    c =  *(cp -  *p++ ); x += c;
		    c =  *(cp -  *p++ ); x += 2 * c;
		    c =  *(cp -  *p); x += 3 * c;
		    p += 76 - 6;

		    c =  *(cp -  *p++ ); x -= 3 * c; y += c;
		    c =  *(cp -  *p++ ); x -= 2 * c; y += c;
		    c =  *(cp -  *p++ ); x -= c; y += c;
		    c =  *(cp -  *p++ ); y += c;
		    c =  *(cp -  *p++ ); x += c; y += c;
		    c =  *(cp -  *p++ ); x += 2 * c; y += c;
		    c =  *(cp -  *p); x += 3 * c; y += c;
		    p += 76 - 5;

		    c =  *(cp -  *p++ ); x -= 2 * c; y += 2 * c;
		    c =  *(cp -  *p++ ); x -= c; y += 2 * c;
		    c =  *(cp -  *p++ ); y += 2 * c;
		    c =  *(cp -  *p++ ); x += c; y += 2 * c;
		    c =  *(cp -  *p); x += 2 * c; y += 2 * c;
		    p += 76 - 3;

		    c =  *(cp -  *p++ ); x -= c; y += 3 * c;
		    c =  *(cp -  *p++ ); y += 3 * c;
		    c =  *(cp -  *p); x += c; y += 3 * c;

		    z = sqrt((float)((x * x) + (y * y)));
		    if (z > (9.000000000000000e-01 * (float)n))
		    {   
			do_symmetry = 0;
			if (x == 0)
			    z = 1.000000000000000e+06;
			else 
			    z = ((float)y) / ((float)x);
			if (z < 0) { z =  -z; w =  -1;
			}
			else 

#line 172 "susan_edges.sc"
			    w = 1;
			if (z < 5.000000000000000e-01) { a = 0; b = 1;
			}
			else 

#line 174 "susan_edges.sc"
			{    if (z > 2.000000000000000e+00) { a = 1; b = 0;
			    }
			    else 

#line 175 "susan_edges.sc"
			    {    if (w > 0) { a = 1; b = 1;
				}
				else 

#line 176 "susan_edges.sc"
				{    a =  -1; b = 1;
				}
			    }
			}

#line 177 "susan_edges.sc"
			if ((m > r[(i + a) * 76 + j + b]) && (m >= r[(i - a) * 76 + j - b]) && 
			    (m > r[(i + (2 * a)) * 76 + j + (2 * b)]) && (m >= r[(i - (2 * a)) * 76 + j - (2 * b)]))
			    mid[i * 76 + j] = 1;
		    }
		    else 
			do_symmetry = 1;
		}
		else 
		    do_symmetry = 1;

		if (do_symmetry == 1)
		{   
		    p = image_buffer + (i - 3) * 76 + j - 1;
		    x = 0; y = 0; w = 0;

#line 196 "susan_edges.sc"
		    c =  *(cp -  *p++ ); x += c; y += 9 * c; w += 3 * c;
		    c =  *(cp -  *p++ ); y += 9 * c;
		    c =  *(cp -  *p); x += c; y += 9 * c; w -= 3 * c;
		    p += 76 - 3;

		    c =  *(cp -  *p++ ); x += 4 * c; y += 4 * c; w += 4 * c;
		    c =  *(cp -  *p++ ); x += c; y += 4 * c; w += 2 * c;
		    c =  *(cp -  *p++ ); y += 4 * c;
		    c =  *(cp -  *p++ ); x += c; y += 4 * c; w -= 2 * c;
		    c =  *(cp -  *p); x += 4 * c; y += 4 * c; w -= 4 * c;
		    p += 76 - 5;

		    c =  *(cp -  *p++ ); x += 9 * c; y += c; w += 3 * c;
		    c =  *(cp -  *p++ ); x += 4 * c; y += c; w += 2 * c;
		    c =  *(cp -  *p++ ); x += c; y += c; w += c;
		    c =  *(cp -  *p++ ); y += c;
		    c =  *(cp -  *p++ ); x += c; y += c; w -= c;
		    c =  *(cp -  *p++ ); x += 4 * c; y += c; w -= 2 * c;
		    c =  *(cp -  *p); x += 9 * c; y += c; w -= 3 * c;
		    p += 76 - 6;

		    c =  *(cp -  *p++ ); x += 9 * c;
		    c =  *(cp -  *p++ ); x += 4 * c;
		    c =  *(cp -  *p); x += c;
		    p += 2;
		    c =  *(cp -  *p++ ); x += c;
		    c =  *(cp -  *p++ ); x += 4 * c;
		    c =  *(cp -  *p); x += 9 * c;
		    p += 76 - 6;

		    c =  *(cp -  *p++ ); x += 9 * c; y += c; w -= 3 * c;
		    c =  *(cp -  *p++ ); x += 4 * c; y += c; w -= 2 * c;
		    c =  *(cp -  *p++ ); x += c; y += c; w -= c;
		    c =  *(cp -  *p++ ); y += c;
		    c =  *(cp -  *p++ ); x += c; y += c; w += c;
		    c =  *(cp -  *p++ ); x += 4 * c; y += c; w += 2 * c;
		    c =  *(cp -  *p); x += 9 * c; y += c; w += 3 * c;
		    p += 76 - 5;

		    c =  *(cp -  *p++ ); x += 4 * c; y += 4 * c; w -= 4 * c;
		    c =  *(cp -  *p++ ); x += c; y += 4 * c; w -= 2 * c;
		    c =  *(cp -  *p++ ); y += 4 * c;
		    c =  *(cp -  *p++ ); x += c; y += 4 * c; w += 2 * c;
		    c =  *(cp -  *p); x += 4 * c; y += 4 * c; w += 4 * c;
		    p += 76 - 3;

		    c =  *(cp -  *p++ ); x += c; y += 9 * c; w -= 3 * c;
		    c =  *(cp -  *p++ ); y += 9 * c;
		    c =  *(cp -  *p); x += c; y += 9 * c; w += 3 * c;

		    if (y == 0)
			z = 1.000000000000000e+06;
		    else 
			z = ((float)x) / ((float)y);
		    if (z < 5.000000000000000e-01) { a = 0; b = 1;
		    }
		    else 

#line 251 "susan_edges.sc"
		    {    if (z > 2.000000000000000e+00) { a = 1; b = 0;
			}
			else 

#line 252 "susan_edges.sc"
			{    if (w > 0) { a =  -1; b = 1;
			    }
			    else 

#line 253 "susan_edges.sc"
			    {    a = 1; b = 1;
			    }
			}
		    }

#line 254 "susan_edges.sc"
		    if ((m > r[(i + a) * 76 + j + b]) && (m >= r[(i - a) * 76 + j - b]) && 
			(m > r[(i + (2 * a)) * 76 + j + (2 * b)]) && (m >= r[(i - (2 * a)) * 76 + j - (2 * b)]))
			mid[i * 76 + j] = 2;
		}
	    }
	}
	myOS.time_wait(20000000);
    }
}

#line 2188 "susan_edge_detector.cc"
SusanEdges_ReadInput::SusanEdges_ReadInput(unsigned int _idcnt, i_uchar7220_receiver (&in_image), unsigned char (&in_image_buffer)[7220], int (&r)[7220], unsigned char (&mid)[7220], OSAPI (&myOS))
    : _specc::behavior(_idcnt), in_image(in_image), in_image_buffer(in_image_buffer), r(r), mid(mid), myOS(myOS)
{   /* nothing */
}

SusanEdges_ReadInput::~SusanEdges_ReadInput(void)
{   /* nothing */
}

#line 269 "susan_edges.sc"
void SusanEdges_ReadInput::main(void) {
    int myTask;
    myTask = myOS.pre_wait();

    in_image.receive( &in_image_buffer);
    myOS.post_wait(myTask);

    memset(mid, 100, 76 * 95);
    memset(r, 0, 76 * 95 * sizeof(int));
}

#line 2210 "susan_edge_detector.cc"
SusanEdges_WriteOutput::SusanEdges_WriteOutput(unsigned int _idcnt, i_int7220_sender (&out_r), i_uchar7220_sender (&out_mid), i_uchar7220_sender (&out_image), int (&r)[7220], unsigned char (&mid)[7220], unsigned char (&out_image_buffer)[7220])
    : _specc::behavior(_idcnt), out_r(out_r), out_mid(out_mid), out_image(out_image), r(r), mid(mid), out_image_buffer(out_image_buffer)
{   /* nothing */
}

SusanEdges_WriteOutput::~SusanEdges_WriteOutput(void)
{   /* nothing */
}

#line 286 "susan_edges.sc"
void SusanEdges_WriteOutput::main(void) {
    out_r.send(r);

    out_mid.send(mid);

    out_image.send(out_image_buffer);
    printf("susan_edges_writeOutput_done\n");
}

#line 2230 "susan_edge_detector.cc"
SusanEdges_PartA::SusanEdges_PartA(unsigned int _idcnt, unsigned char (&image_buffer)[7220], int (&r)[7220], unsigned char (&bp)[516], OSAPI (&myOS))
    : _specc::behavior(_idcnt), image_buffer(image_buffer), r(r), bp(bp), myOS(myOS),
    _scc_const_port_0(0),
    _scc_const_port_1(1),
    susan_edges_a_thread_0(_IDcnt, image_buffer, r, bp, _scc_const_port_0, myOS),
    susan_edges_a_thread_1(_IDcnt, image_buffer, r, bp, _scc_const_port_1, myOS)
{   /* nothing */
}

SusanEdges_PartA::~SusanEdges_PartA(void)
{   /* nothing */
}

#line 302 "susan_edges.sc"
void SusanEdges_PartA::main(void) {
    susan_edges_a_thread_0.main();
    susan_edges_a_thread_1.main();
}

#line 2250 "susan_edge_detector.cc"
SusanEdges_PartB::SusanEdges_PartB(unsigned int _idcnt, unsigned char (&image_buffer)[7220], int (&r)[7220], unsigned char (&mid)[7220], unsigned char (&bp)[516], OSAPI (&myOS))
    : _specc::behavior(_idcnt), image_buffer(image_buffer), r(r), mid(mid), bp(bp), myOS(myOS),
    _scc_const_port_0(0),
    _scc_const_port_1(1),
    susan_edges_b_thread_0(_IDcnt, image_buffer, r, mid, bp, _scc_const_port_0, myOS),
    susan_edges_b_thread_1(_IDcnt, image_buffer, r, mid, bp, _scc_const_port_1, myOS)
{   /* nothing */
}

SusanEdges_PartB::~SusanEdges_PartB(void)
{   /* nothing */
}

#line 314 "susan_edges.sc"
void SusanEdges_PartB::main(void) {
    susan_edges_b_thread_0.main();
    susan_edges_b_thread_1.main();
}

#line 2270 "susan_edge_detector.cc"
SusanEdges::SusanEdges(unsigned int _idcnt, i_uchar7220_receiver (&in_image), i_int7220_sender (&out_r), i_uchar7220_sender (&out_mid), unsigned char (&bp)[516], i_uchar7220_sender (&out_image), OSAPI (&myOS))
    : _specc::behavior(_idcnt), in_image(in_image), out_r(out_r), out_mid(out_mid), bp(bp), out_image(out_image), myOS(myOS),
    susan_edges_a(_IDcnt, image_buffer, r, bp, myOS),
    susan_edges_b(_IDcnt, image_buffer, r, mid, bp, myOS),
    susan_edges_read_input(_IDcnt, in_image, image_buffer, r, mid, myOS),
    susan_edges_write_output(_IDcnt, out_r, out_mid, out_image, r, mid, image_buffer)
{   /* nothing */
}

SusanEdges::~SusanEdges(void)
{   /* nothing */
}

#line 334 "susan_edges.sc"
void SusanEdges::main(void) {

    { enum { _scc_state_0, _scc_state_susan_edges_read_input, _scc_state_susan_edges_a, _scc_state_susan_edges_b, _scc_state_susan_edges_write_output } _scc_next_state = _scc_state_susan_edges_read_input; do switch(_scc_next_state) {
	    case _scc_state_susan_edges_read_input: { susan_edges_read_input.main(); { _scc_next_state = _scc_state_susan_edges_a; break; } }
	    case _scc_state_susan_edges_a: { susan_edges_a.main(); { _scc_next_state = _scc_state_susan_edges_b; break; } }
	    case _scc_state_susan_edges_b: { susan_edges_b.main(); { _scc_next_state = _scc_state_susan_edges_write_output; break; } }
	    case _scc_state_susan_edges_write_output: { susan_edges_write_output.main(); { _scc_next_state = _scc_state_0; break; } } case _scc_state_0: { _scc_next_state = _scc_state_0; break; } } while(_scc_next_state != _scc_state_0);
    }
}

#line 2295 "susan_edge_detector.cc"
SusanThinThread::SusanThinThread(unsigned int _idcnt, int (&r)[7220], unsigned char (&mid)[7220], int (&thID), OSAPI (&myOS))
    : _specc::behavior(_idcnt), r(r), mid(mid), thID(thID), myOS(myOS)
{   /* nothing */
}

SusanThinThread::~SusanThinThread(void)
{   /* nothing */
}

#line 8 "susan_thin.sc"
void SusanThinThread::main(void) {
    int centre; int l[9];
    int b01; int b10; int b12; int b21;
    int p1; int p2; int p3; int p4;
    int b00; int b02; int b20; int b22;
    int a; int b; int i; int j; int m; int n; int x; int y;
    unsigned char *mp;

    for(i = 4 + (95 - 4 - 4) / 2 * thID; i < 4 + (95 - 4 - 4) / 2 * (thID + 1) + (thID + 1 == 2 && (95 - 4 - 4) % 2 != 0 ? (95 - 4 - 4) % 2 : 0); i++ )
    {   

	for(j = 4; j < 76 - 4; j++ )
	    if (mid[i * 76 + j] < 8)
	    {   
		centre = r[i * 76 + j];


		mp = mid + (i - 1) * 76 + j - 1;

		n = ( *mp < 8) + 
		( *(mp + 1) < 8) + 
		( *(mp + 2) < 8) + 
		( *(mp + 76) < 8) + 
		( *(mp + 76 + 2) < 8) + 
		( *(mp + 76 + 76) < 8) + 
		( *(mp + 76 + 76 + 1) < 8) + 
		( *(mp + 76 + 76 + 2) < 8);



		if (n == 0)
		    mid[i * 76 + j] = 100;




		if ((n == 1) && (mid[i * 76 + j] < 6))
		{   

#line 52 "susan_thin.sc"
		    l[0] = r[(i - 1) * 76 + j - 1]; l[1] = r[(i - 1) * 76 + j]; l[2] = r[(i - 1) * 76 + j + 1];
		    l[3] = r[(i) * 76 + j - 1]; l[4] = 0; l[5] = r[(i) * 76 + j + 1];
		    l[6] = r[(i + 1) * 76 + j - 1]; l[7] = r[(i + 1) * 76 + j]; l[8] = r[(i + 1) * 76 + j + 1];

		    if (mid[(i - 1) * 76 + j - 1] < 8) { l[0] = 0; l[1] = 0; l[3] = 0; l[2] *= 2;
			l[6] *= 2; l[5] *= 3; l[7] *= 3; l[8] *= 4;
		    }
		    else 

#line 58 "susan_thin.sc"
		    {    if (mid[(i - 1) * 76 + j] < 8) { l[1] = 0; l[0] = 0; l[2] = 0; l[3] *= 2;
			    l[5] *= 2; l[6] *= 3; l[8] *= 3; l[7] *= 4;
			}
			else 

#line 60 "susan_thin.sc"
			{    if (mid[(i - 1) * 76 + j + 1] < 8) { l[2] = 0; l[1] = 0; l[5] = 0; l[0] *= 2;
				l[8] *= 2; l[3] *= 3; l[7] *= 3; l[6] *= 4;
			    }
			    else 

#line 62 "susan_thin.sc"
			    {    if (mid[(i) * 76 + j - 1] < 8) { l[3] = 0; l[0] = 0; l[6] = 0; l[1] *= 2;
				    l[7] *= 2; l[2] *= 3; l[8] *= 3; l[5] *= 4;
				}
				else 

#line 64 "susan_thin.sc"
				{    if (mid[(i) * 76 + j + 1] < 8) { l[5] = 0; l[2] = 0; l[8] = 0; l[1] *= 2;
					l[7] *= 2; l[0] *= 3; l[6] *= 3; l[3] *= 4;
				    }
				    else 

#line 66 "susan_thin.sc"
				    {    if (mid[(i + 1) * 76 + j - 1] < 8) { l[6] = 0; l[3] = 0; l[7] = 0; l[0] *= 2;
					    l[8] *= 2; l[1] *= 3; l[5] *= 3; l[2] *= 4;
					}
					else 

#line 68 "susan_thin.sc"
					{    if (mid[(i + 1) * 76 + j] < 8) { l[7] = 0; l[6] = 0; l[8] = 0; l[3] *= 2;
						l[5] *= 2; l[0] *= 3; l[2] *= 3; l[1] *= 4;
					    }
					    else 

#line 70 "susan_thin.sc"
					    {    if (mid[(i + 1) * 76 + j + 1] < 8) { l[8] = 0; l[5] = 0; l[7] = 0; l[6] *= 2;
						    l[2] *= 2; l[1] *= 3; l[3] *= 3; l[0] *= 4;
						}
					    }
					}
				    }
				}
			    }
			}
		    }

#line 73 "susan_thin.sc"
		    m = 0;
		    for(y = 0; y < 3; y++ )
			for(x = 0; x < 3; x++ )
			    if (l[y + y + y + x] > m) { m = l[y + y + y + x]; a = y; b = x;
			    }
		    if (m > 0)
		    {   
			if (mid[i * 76 + j] < 4)
			    mid[(i + a - 1) * 76 + j + b - 1] = 4;
			else 
			    mid[(i + a - 1) * 76 + j + b - 1] = mid[i * 76 + j] + 1;
			if ((a + a + b) < 3)
			{   
			    i += a - 1;
			    j += b - 2;
			    if (i < 4) i = 4;
			    if (j < 4) j = 4;
			}
		    }
		}

		if (n == 2)
		{   

		    b00 = mid[(i - 1) * 76 + j - 1] < 8;
		    b02 = mid[(i - 1) * 76 + j + 1] < 8;
		    b20 = mid[(i + 1) * 76 + j - 1] < 8;
		    b22 = mid[(i + 1) * 76 + j + 1] < 8;
		    if (((b00 + b02 + b20 + b22) == 2) && ((b00 | b22) & (b02 | b20)))
		    {   



			if (b00)
			{   
			    if (b02) { x = 0; y =  -1;
			    }
			    else 

#line 109 "susan_thin.sc"
			    {    x =  -1; y = 0;
			    }
			}
			else  {
			    if (b02) { x = 1; y = 0;
			    }
			    else 

#line 114 "susan_thin.sc"
			    {    x = 0; y = 1;
			    }
			} if (((float)r[(i + y) * 76 + j + x] / (float)centre) > 7.000000000000000e-01)
			{   
			    if (((x == 0) && (mid[(i + (2 * y)) * 76 + j] > 7) && (mid[(i + (2 * y)) * 76 + j - 1] > 7) && (mid[(i + (2 * y)) * 76 + j + 1] > 7)) || 
				((y == 0) && (mid[(i) * 76 + j + (2 * x)] > 7) && (mid[(i + 1) * 76 + j + (2 * x)] > 7) && (mid[(i - 1) * 76 + j + (2 * x)] > 7)))
			    {   
				mid[(i) * 76 + j] = 100;
				mid[(i + y) * 76 + j + x] = 3;
			    }
			}
		    }
		    else 
		    {   
			b01 = mid[(i - 1) * 76 + j] < 8;
			b12 = mid[(i) * 76 + j + 1] < 8;
			b21 = mid[(i + 1) * 76 + j] < 8;
			b10 = mid[(i) * 76 + j - 1] < 8;

#line 156 "susan_thin.sc"
			if (((b01 + b12 + b21 + b10) == 2) && ((b10 | b12) & (b01 | b21)) && 
			    ((b01 & ((mid[(i - 2) * 76 + j - 1] < 8) | (mid[(i - 2) * 76 + j + 1] < 8))) | (b10 & ((mid[(i - 1) * 76 + j - 2] < 8) | (mid[(i + 1) * 76 + j - 2] < 8))) | 
				(b12 & ((mid[(i - 1) * 76 + j + 2] < 8) | (mid[(i + 1) * 76 + j + 2] < 8))) | (b21 & ((mid[(i + 2) * 76 + j - 1] < 8) | (mid[(i + 2) * 76 + j + 1] < 8)))))
			{   



			    mid[(i) * 76 + j] = 100;
			    i-- ;
			    j -= 2;
			    if (i < 4) i = 4;
			    if (j < 4) j = 4;
			}
		    }
		}

		if (n > 2)
		{   
		    b01 = mid[(i - 1) * 76 + j] < 8;
		    b12 = mid[(i) * 76 + j + 1] < 8;
		    b21 = mid[(i + 1) * 76 + j] < 8;
		    b10 = mid[(i) * 76 + j - 1] < 8;
		    if ((b01 + b12 + b21 + b10) > 1)
		    {   
			b00 = mid[(i - 1) * 76 + j - 1] < 8;
			b02 = mid[(i - 1) * 76 + j + 1] < 8;
			b20 = mid[(i + 1) * 76 + j - 1] < 8;
			b22 = mid[(i + 1) * 76 + j + 1] < 8;
			p1 = b00 | b01;
			p2 = b02 | b12;
			p3 = b22 | b21;
			p4 = b20 | b10;

			if (((p1 + p2 + p3 + p4) - ((b01 & p2) + (b12 & p3) + (b21 & p4) + (b10 & p1))) < 2)
			{   
			    mid[(i) * 76 + j] = 100;
			    i-- ;
			    j -= 2;
			    if (i < 4) i = 4;
			    if (j < 4) j = 4;
			}
		    }
		}
	    }
	myOS.time_wait(6400000);
    }
}

#line 2521 "susan_edge_detector.cc"
SusanThin_ReadInput::SusanThin_ReadInput(unsigned int _idcnt, i_int7220_receiver (&in_r), i_uchar7220_receiver (&in_mid), int (&r)[7220], unsigned char (&mid)[7220])
    : _specc::behavior(_idcnt), in_r(in_r), in_mid(in_mid), r(r), mid(mid)
{   /* nothing */
}

SusanThin_ReadInput::~SusanThin_ReadInput(void)
{   /* nothing */
}

#line 209 "susan_thin.sc"
void SusanThin_ReadInput::main(void) {
    in_r.receive( &r);
    in_mid.receive( &mid);
}

#line 2537 "susan_edge_detector.cc"
SusanThin_WriteOutput::SusanThin_WriteOutput(unsigned int _idcnt, i_uchar7220_sender (&out_mid), unsigned char (&mid)[7220])
    : _specc::behavior(_idcnt), out_mid(out_mid), mid(mid)
{   /* nothing */
}

SusanThin_WriteOutput::~SusanThin_WriteOutput(void)
{   /* nothing */
}

#line 217 "susan_thin.sc"
void SusanThin_WriteOutput::main(void) {
    out_mid.send(mid);
    printf("susan_THIN_done\n");
}

#line 2553 "susan_edge_detector.cc"
SusanThin::SusanThin(unsigned int _idcnt, int (&r)[7220], unsigned char (&mid)[7220], OSAPI (&myOS))
    : _specc::behavior(_idcnt), r(r), mid(mid), myOS(myOS),
    _scc_const_port_0(0),
    _scc_const_port_1(1),
    susan_thin_thread_0(_IDcnt, r, mid, _scc_const_port_0, myOS),
    susan_thin_thread_1(_IDcnt, r, mid, _scc_const_port_1, myOS)
{   /* nothing */
}

SusanThin::~SusanThin(void)
{   /* nothing */
}

#line 230 "susan_thin.sc"
void SusanThin::main(void) {

    susan_thin_thread_0.main();

    susan_thin_thread_1.main();
}

#line 2575 "susan_edge_detector.cc"
Thin::Thin(unsigned int _idcnt, i_int7220_receiver (&in_r), i_uchar7220_receiver (&in_mid), i_uchar7220_sender (&out_mid), OSAPI (&myOS))
    : _specc::behavior(_idcnt), in_r(in_r), in_mid(in_mid), out_mid(out_mid), myOS(myOS),
    susan_thin(_IDcnt, r, mid, myOS),
    susan_thin_read_input(_IDcnt, in_r, in_mid, r, mid),
    susan_thin_write_output(_IDcnt, out_mid, mid)
{   /* nothing */
}

Thin::~Thin(void)
{   /* nothing */
}

#line 249 "susan_thin.sc"
void Thin::main(void) {
    int task_id = 1;
    myOS.task_activate(task_id);

    { enum { _scc_state_0, _scc_state_susan_thin_read_input, _scc_state_susan_thin, _scc_state_susan_thin_write_output } _scc_next_state = _scc_state_susan_thin_read_input; do switch(_scc_next_state) {
	    case _scc_state_susan_thin_read_input: { susan_thin_read_input.main(); { _scc_next_state = _scc_state_susan_thin; break; } }
	    case _scc_state_susan_thin: { susan_thin.main(); { _scc_next_state = _scc_state_susan_thin_write_output; break; } }
	    case _scc_state_susan_thin_write_output: { susan_thin_write_output.main(); { _scc_next_state = _scc_state_susan_thin_read_input; break; } } case _scc_state_0: { _scc_next_state = _scc_state_0; break; } } while(_scc_next_state != _scc_state_0);
    }
}

#line 2600 "susan_edge_detector.cc"
WriteImage::WriteImage(unsigned int _idcnt, i_uchar7220_receiver (&in_image), i_sender (&out_image))
    : _specc::behavior(_idcnt), in_image(in_image), out_image(out_image)
{   /* nothing */
}

WriteImage::~WriteImage(void)
{   /* nothing */
}

#line 9 "write_image.sc"
void WriteImage::main(void) {

    unsigned char image_buffer[7220];

    while(true) {
	printf("WR_start\n");
	in_image.receive( &image_buffer);
	out_image.send(image_buffer, sizeof (image_buffer));
    }
}

#line 2622 "susan_edge_detector.cc"
void _scc_range_check(
    unsigned long long Time1, 
    unsigned long long Time2, 
    unsigned long long Min, 
    bool CheckMin, 
    unsigned long long Max, 
    bool CheckMax, 
    const char *Label1, 
    const char *Label2, 
    const char *File, 
    unsigned int Line)
{   
    char BuffMin[40],BuffMax[40],BuffT2[40],BuffT1[40],BuffT[40];
    if (((CheckMin)&&(Time2-Time1 < Min)) || ((CheckMax)&&(Time2-Time1 > Max)))
    {   _specc::abort(
	    "ERROR:\tRange check failed in line %d\n"
	    "\tin file \"%s\":\n"
	    "\trange(%s; %s; %s; %s) is %s - %s = %s.\n"
	    "Simulation aborted.\n",
	    Line, File,
	    Label1, Label2, ull2str(10,&BuffMin[39],Min), ull2str(10,&BuffMax[39],Max),
	    ull2str(10,&BuffT2[39],Time2), ull2str(10,&BuffT1[39],Time1), ull2str(10,&BuffT[39],Time2 - Time1));
    }
}

void _scc_bit4_err_handle(
    const _bit4& bit4vec)
{   
    char temp_bits[1024], *p;
    p=bit2str(2,&temp_bits[1023], bit4vec);
    _specc::abort(
	"ERROR:\t Casting a bit4 vector failed \n"
	"Bit4 vector contains X/Z values %s\n"
	"Simulation aborted.\n", p);
	
}

//////////////////////////////////////////////////////////////////////
// End of file susan_edge_detector.cc
//////////////////////////////////////////////////////////////////////
